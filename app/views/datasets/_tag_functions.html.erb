<%# This function builds a list of data layers that are registered, and are thus stored in the database.
    Layers are actually objects with a type and rubyId field.  Display name should come from the data server itself, and will
      be retrieved separately %>

<script type="text/javascript">

  var deleteTagClickHandler = function(ctrl)
  {
    var serverUrl         = ctrl.data('url');
    var datasetIdentifier = ctrl.data('identifier');
    var tagVal            = ctrl.parent().text().trim();
    
    if(confirmDeleteTag(serverUrl, datasetIdentifier, tagVal))
      deleteTag(serverUrl, datasetIdentifier, tagVal);
  };


  var deleteFolderTagClickHandler = function(ctrl)
  {
    // We don't ask for a confirmation here...
    deleteFolderTag(ctrl.data('url'), 
                    ctrl.data('identifier'), 
                    ctrl.parent().text().trim());
  };


  // Take an array or comma-separated list of tags and format them into some presentation quality HTML
  var createTagList = function(taglist, deletable, serverUrl, datasetIdentifier, tagclass) 
  {
    if(taglist.length == 0)
      return "";

    if(typeof(taglist) == "string")
      taglist = taglist.split(",");

    var delBtn = "";

    if(deletable)   // or folder-tag-delete-button
      delBtn = '<span class="' + tagclass + '-delete-button" ' +
               'data-url="' + serverUrl + '" ' +
               'data-identifier="' + datasetIdentifier + '"></span>';

    var renderedList = "";
    var strings = typeof(taglist[0]) == "string";

    for(var i = 0, len = taglist.length; i < len; i++) 
      renderedList += '<span class="' + tagclass + '">' + delBtn +
                       (strings ? taglist[i] : taglist[i].tag) + '</span> ';  // Trailing space required

   return renderedList; 
  };


  var addDeleteTagClickHander = function(isProcessingTag) 
  {
    // Add a handler to delete tags when clicked on
    if(isProcessingTag)
      $('.tag-delete-button')       .on('click', function(event){ deleteTagClickHandler($(this)) });
    else
      $('.folder-tag-delete-button').on('click', function(event){ deleteFolderTagClickHandler($(this)) });
  };


  // This will update any tag lists composed of tags that do have a delete control, such as 
  // the tags entries on the dataset info popups.  Note that we do not combine folder tags and
  // processing tags, and do want to add a 'No Tags' placeholder if the list is empty.
  var doUpdateDeleteableTags = function(serverUrl, datasetIdentifier, id, tags, tagclass)
  {
    var urlId = cssEscape(serverUrl + datasetIdentifier);

    $('.' + id + '-deletable-' + urlId).html(
          createTagList(tags, true, serverUrl, datasetIdentifier, tagclass));

    addDeleteTagClickHander(tagclass == 'tag');
  };


  // This will update any tag lists composed of tags that do not have a delete control, such as 
  // the Tags column of the Registered Datasets screen.  Note that we combine folder tags and
  // processing tags, and do not want to add a 'No Tags' placeholder if the list is empty.
  var doUpdateNonDeleteableTags = function(serverUrl, datasetIdentifier, id, tags, tagclass)
  {
    var urlId = cssEscape(serverUrl + datasetIdentifier);

    $('.' + id + '-' + urlId).html(
          createTagList(tags, false, serverUrl, datasetIdentifier, tagclass));
  };


  var updateTags = function(serverUrl, datasetIdentifier, tags)
  {
    doUpdateDeleteableTags   (serverUrl, datasetIdentifier, 'taglist', tags, 'tag');
    doUpdateNonDeleteableTags(serverUrl, datasetIdentifier, 'taglist', tags, 'tag');
  };


  var updateFolderTags = function(serverUrl, datasetIdentifier, tags)
  {
    doUpdateDeleteableTags   (serverUrl, datasetIdentifier, 'folder-taglist', tags, 'folder-tag');
    doUpdateNonDeleteableTags(serverUrl, datasetIdentifier, 'folder-taglist', tags, 'folder-tag');
  };


  // Some string constants
  var INPUT_FIELD_PREFIX = "new-tag-";
  var IGNORE_THIS        = "__Ignore_This__";
  var NEW_TAG            = "__New_Tag__";


  var tagPickerChanged = function(ctrl)
  {
    ctrl.blur();    // For firefox?

    if(ctrl.val() == IGNORE_THIS) 
      return; 

    addTag(ctrl);
  };


 var folderTagPickerChanged = function(ctrl, tag)
  {
    ctrl.blur();    // For firefox?

    if(ctrl.val() == IGNORE_THIS) 
      return; 

    if(ctrl.val() == NEW_TAG) {
      $("#" + INPUT_FIELD_PREFIX + ctrl[0].id).show();
      $("#" + INPUT_FIELD_PREFIX + ctrl[0].id).focus();
      return;
    }

    addFolderTag(ctrl, tag);
  };


  // TODO: This should really be computed server-side, and should only consider config datasets that we control
  // To understand this mess, the best way to understand what it means is to look at the generated code using
  // view source, and see what it makes.
  TagIsInUse = {};
  <%= raw @datasets.map{ |d| 
          d.config_datasets.map{ |c| 'if(!TagIsInUse["' + c.input_identifier + '"])' +
                                     '  TagIsInUse["' + c.input_identifier + '"] = {};' + 
                                     'if(!TagIsInUse["' + c.input_identifier + '"]' +
                                               '[cssEscape("' + d.server_url.gsub(/\\/, '\\\\\\') + d.identifier + '")]) ' +
                                     '  TagIsInUse["' + c.input_identifier + '"]' +
                                               '[cssEscape("' + d.server_url.gsub(/\\/, '\\\\\\') + d.identifier + '")] = 0;' +
                                     'TagIsInUse["' + c.input_identifier + '"]' +
                                               '[cssEscape("' + d.server_url.gsub(/\\/, '\\\\\\') + d.identifier + '")]++;'
                              }
                      }.join(' ');
  %>   


  var confirmDeleteTag = function(serverUrl, datasetIdentifier, tagVal) 
  {
    if(TagIsInUse[tagVal] && TagIsInUse[tagVal][cssEscape(serverUrl + datasetIdentifier)] > 0) {
      var ct = TagIsInUse[tagVal][cssEscape(serverUrl + datasetIdentifier)];
      var c  = (ct == 1) ? "configuration" : "configurations";
      var t  = (ct == 1) ? "this"          : "these";
      var th = (ct == 1) ? "it"            : "them";

      return confirm("This dataset is in use by " + ct + " " + c + ". " +
                     "Changing its type will cause it to be removed from " + t + " " + c + ".\n\n" +
                     "Click OK if you are sure you want to change the type of this dataset.");
    }
    // else...
    return true;
  };



  // General handler for json requests that return an unexpected error
  var jsonErrorHandler = function(jqXHR, status, error, msg)
  {
    // Often, if we encounter a rails error, jqXHR.status will be 500.  Show that error
    // in a new window because responseText will contain a full HTML document.
    if(jqXHR.status == 500)
    {
      var win = window.open();
      if(win)
      {
        $(win.document.body).html(jqXHR.responseText);
        return;
      }

      // Can't open window... thorow this up as a last ditch effort to report the error
      alert(msg + "  Can't open window... got error: " + jqXHR.responseText + '")');
      return;
    }
    
    alert(msg + ' (server says: "' + jqXHR.responseText + '")');
  };



  // tagType will be true for regular tags, false for folder-tags
  var doAddTag = function(serverUrl, datasetIdentifier, tag, tagType, successFunction)
  {
    var url = tagType ? '<%= url_for(:controller => 'datasets', :action => 'add_data_tag') %>' :
                        '<%= url_for(:controller => 'datasets', :action => 'add_data_folder_tag') %>'

    $.ajax({
      type:    'PUT',     // PUT combined with url below triggers "update" action on controller
      url:     url,       // url includes info about what sort of tag will be added
      data:    'dataset[identifier]='  + datasetIdentifier +
               '&dataset[server_url]=' + serverUrl +
               '&tag_val='             + tag,
      headers: { 'X-CSRF-Token': '<%= form_authenticity_token.to_s %>' /*,
                 'Content-Type': 'application/json' */},
      success: function(data) { successFunction(serverUrl, datasetIdentifier, eval(data)); },
      error:   function(jqXHR, status, error) { 
                  jsonErrorHandler(jqXHR, status, error, "Could not add tag!");
               }
    });
  };


  // User adds or removes a tag
  var addTag = function(ctrl)
  {
    var datasetIdentifier = ctrl.data('datasetidentifier');
    var serverUrl         = ctrl.data('serverurl');
    var tag = ctrl.val();

    doAddTag(serverUrl, datasetIdentifier, tag, true, updateTags);
  };


  // User adds or removes a tag
  var addFolderTag = function(ctrl, tag)
  {
    var datasetIdentifier = ctrl.data('datasetidentifier');
    var serverUrl         = ctrl.data('serverurl');

    doAddTag(serverUrl, datasetIdentifier, tag, false, updateFolderTags);
  };


  // tagType will be true for regular tags, false for folder-tags
  var doDeleteTag = function(datasetIdentifier, serverUrl, tagValue, tagType, successFunction)
  {
    $.ajax({
      type:    'PUT',      // PUT combined with url below triggers "update" action on controller
      url:     '<%= url_for(:controller => "datasets", :action => "del_tag") %>',
      data:    'dataset[identifier]='  + datasetIdentifier +
               '&dataset[server_url]=' + serverUrl +
               '&tag_type='            + (tagType ? 'proc' : 'folder') +
               '&tag_val='             + tagValue,
      headers: { 'X-CSRF-Token': '<%= form_authenticity_token.to_s %>' /*,
                 'Content-Type': 'application/json' */},
      success: function(data) { successFunction(serverUrl, datasetIdentifier, eval(data)); },
      error:   function(jqXHR, status, error) { 
                  jsonErrorHandler(jqXHR, status, error, "Could not delete tag!");
               }
    });
  };


  var deleteTag = function(serverUrl, datasetIdentifier, tagValue)
  {
    doDeleteTag(datasetIdentifier, serverUrl, tagValue, true, updateTags);
  };


  var deleteFolderTag = function(serverUrl, datasetIdentifier, tagValue)
  {
    doDeleteTag(datasetIdentifier, serverUrl, tagValue, false, updateFolderTags);
  };


  // Dict to keep track of user added folder tags 
  var tagLists = {};


  var resizeInputField = function(fieldName)
  {
    // Resize input field to fit neatly inside the fake input box
    var input = $('#input-' + fieldName);

    var width = input.parent().width() - input.prevAll().width();

    // If resulting width is too small, bump it up to a min size
    if(width < 50)
      width = 50;

    input.width(width);
    input.parent().scrollLeft(99999);
  };


  // Add a folder tag to the specified dataset... send the addition to the server
  var addFolderTagXXX = function(fieldName, tag, rebuilding)
  {
    if(tag === "")
      return;

    // Create a new container for tags if we don't already have one
    if(!tagLists[fieldName])
      tagLists[fieldName] = [];

    // Check if we already have the tag... don't add it twice!
    if(!rebuilding)
    {
      var index = tagLists[fieldName].indexOf(tag);
      if(index > -1)
        return;    

      tagLists[fieldName].push(tag);
    }

    // Trailing space required below!
    var tagCode = "<span class='folder-tag'>" + 
                    "<span class='folder-tag-delete-button' " +
                          "onclick='delTagXXX(\"" + fieldName + "\",\"" + tag + "\"); return false;'></span>" + 
                  tag + "</span> "; 

    $('span[name="tags-' + fieldName + '"]').append(tagCode);  

    // If we're rebuilding the list, we'll resize the input field when we're done, rather than doing
    // it as we call this function repeatedly
    if(!rebuilding)
      resizeInputField(fieldName);

    // Alert the server of the new tag
    if(!rebuilding)
    {
      var ctrl = $('#input-' + fieldName);
      var datasetUrl        = ctrl.data('serverurl');
      var datasetIdentifier = ctrl.data('datasetidentifier');

      doAddTag(datasetUrl, datasetIdentifier, tag, false, updateFolderTags);
    }
  };


  var delTagXXX = function(fieldName, tag)
  {
    var index = tagLists[fieldName].indexOf(tag);
    if(index > -1)
      tagLists[fieldName].splice(index, 1);

    // Rebuild tag list without the deleted tag
    $('span[name="tags-' + fieldName + '"]').empty();
    for(var i=0, len=tagLists[fieldName].length; i < len; i++)
      addFolderTagXXX(fieldName, tagLists[fieldName][i], true);

    resizeInputField(fieldName);
  };


  // fieldName looks like "tagEntry8"
  var clearTagMatchCandidateList = function(fieldName)
  {
    $('#matches-' + fieldName).empty();
    $('#matches-' + fieldName).hide();
  };


  var folderTagMatchCandidateClicked = function(fieldName, tag)
  {
    addFolderTagXXX(fieldName, tag, false);   
    clearTagMatchCandidateList(fieldName);
    $('#input-' + fieldName).val("");   // Remove any partially typed tags
  };


  // Show the list of possible tag matches.  Matches will be shown as tags that can be clicked to complete
  // a partially typed tag.
  var showTagMatches = function(fieldName, tagList)
  {
    if(tagList === "") {
      clearTagMatchCandidateList(fieldName);
      return;
    }

    var matchList = "";

    for(var tag; tag = tagList.pop();) {

      // Skip matches that are in use here
      if(tagLists[fieldName] && tagLists[fieldName].hasObject(tag))
        continue;

      var code = 'folderTagMatchCandidateClicked("' + fieldName + '", "' + tag + '"); return false;';
      matchList += "<span class='folder-tag clickable' onclick='" + code + "'>" + tag + "</span> ";  // Trailing space required
    }

    console.log(":ML: ",matchList);

    $('#matches-' + fieldName).html("Possible matches:<br>" + matchList);
    $('#matches-' + fieldName).show();
  };


  // Handles success callback from findMatchingTags
  var foundMatchingTags = function(jqXHR)
  {
    var fieldName    = jqXHR.data[0].fieldname;
    var matchingTags = jqXHR.data[0].matching_tags;

    showTagMatches(fieldName, matchingTags);
  };


  // Check if we already have a dataset with this name; tagFragment should always have some value
  var findMatchingTags = function(tagFragment, fieldName)
  {
    var serverUrl = '<%= url_for(:controller => "datasets", :action => "find_matching_tags", :format => :json) %>';
    $.ajax({
        type: 'GET',
        url: serverUrl,
        data: 'prefix=' + tagFragment + '&field_name=' + fieldName,
        headers: { 'X-CSRF-Token': '<%= form_authenticity_token.to_s %>' },
        success: foundMatchingTags,
        error: function(jqXHR, textStatus, error) { jsonErrorHandler(jqXHR, status, error, "Error looking for tags!"); }
      });
  }


  var onFolderTagEntryChanged = function(field) 
  { 
    var words = field.value.split(",");

    // Last word will be "" when field.value ends with a space, so
    // user has ended a word and we should add the tag
    if(field.value !== "" && words[words.length - 1] === "") {
      addFolderTagXXX(field.name, words[words.length - 2], false);
      field.value = "";
      clearTagMatchCandidateList(field.name);
    }

    // field.value does not end in space, so still typing a word
    else if(words[words.length - 1] !== "")
      findMatchingTags(words[words.length - 1], field.name);

    // Otherwise, field must be empty
    else
      showTagMatches(field.name, "");
  }


  // Generate a tag list for the specified layer
  // regLyr is an object that has tags and folder_tags fields
  var makeTagList = function(layer, regLyr, urlId, placeholder) 
  {
    if(!regLyr)
      return placeholder;

    if(!regLyr.tags && !regLyr.tags)
      return placeholder;

    return '<span class="folder-taglist-deletable-' + urlId + ' taglist">' + 
        createTagList(regLyr.folder_tags, true, layer.serverUrl, layer.identifier, 'folder-tag') +
      '</span>' +

      '<span class="taglist-deletable-' + urlId + ' taglist">' + 
        createTagList(regLyr.tags, true, layer.serverUrl, layer.identifier, 'tag') +
      '</span>';
  };


  // We can pass in anything for layer as long as it has an identifier property
  var makeTagPickerControl = function(layer, controlId, enabled)
  {
    return '<select style="float:right" class="add-tag-dropdown-control" ' +
             'data-serverurl="' + layer.serverUrl + '" ' + 
             'data-datasetidentifier="' + layer.identifier + '" ' +
             'id="' + controlId + '" ' + (enabled ? '' : 'disabled="true" ') +
             'onchange="tagPickerChanged($(this));">' +
               '<option value = "' + IGNORE_THIS + '">Add Processing Tag:</option>' + 
           '</select>';
  };


  // Gets run when user enters a new folderTag
  var tagManuallyEntered = function(ctrl, selectId) 
  {
    addFolderTag(ctrl, ctrl.val());
    ctrl.val('');
    ctrl.hide();
    $('#' + selectId).val(IGNORE_THIS);
  };


  // tagEntryFieldName --> This should be some unique identifier (string) for the field
  // layer --> some object that has both an identifier and serverUrl field
  // regLyr --> some object that has tags and folder_tags fields
  var createFolderTagControl = function(layer, tagEntryFieldName, tagPickerControlId, enabled)
  {
    var selectId = "input-" + tagEntryFieldName;
    var newTagInputId = INPUT_FIELD_PREFIX + selectId;

    return '<div style="position: relative;display: inline;">' +
             '<input style="display:none;" ' + 
                'id="' + newTagInputId + '" ' + 
                'onchange="tagManuallyEntered($(this), \'' + selectId + '\'); return false;" ' +
                'data-serverurl="'         + layer.serverUrl  + '" ' +   
                'data-datasetidentifier="' + layer.identifier + '">' +
             '<select style="float:right" class="add-tag-dropdown-control" ' +
               'data-serverurl="'         + layer.serverUrl  + '" ' +   
               'data-datasetidentifier="' + layer.identifier + '" ' +
               'id="'                     + selectId + '" ' + 
                    (enabled ? '' : 'disabled="true" ') +
               'onchange="folderTagPickerChanged($(this), $(this).val());">' +
                 '<option value = "' + IGNORE_THIS + '">Add Mapping Tag:</option>' + 
                 '<option value = "' + NEW_TAG + '">Add New Tag</option>' +
                 '<% getAliveFolderTags().each do |t| %><option value="<%= t %>"><%= t %></option><% end %>' +
             '</select>' +
           '</div>';
  };

</script>
