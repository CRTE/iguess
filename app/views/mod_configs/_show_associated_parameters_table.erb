<!-- Print a table of parameters for the module specified in mod -->

<!--<% newConfig = newConfig || false %>  <%# True if we're creating a new configuration, false if editing an existing one %>-->

<label class="simple_form label"><%= mode.slice(0,1).capitalize + mode.slice(1..-1) %>s</label>
<table class="zebra" id="<%= mode %>-table">
  <!-- Will be populated below -->
</table>


<script type="text/javascript">

  var anyDatasetsMissing = false;

  <% if mode == :input %>  <%# Only include this once %>
    // Gets triggered when a selected dataset changes, but is only used when editing an existing config 
    function onSelectedDatasetChanged() {
      var identifier = this.name.replace('datasets[', '').slice(0, -1);   // slice strips last char;
      var datasetId  = this.options[this.selectedIndex].value;

      // Tell the server we've changed the selected dataset 
      $.ajax({
        type: 'PUT',      // PUT combined with url below triggers "update" action on controller
        url:  '<%= url_for(:controller => 'config_datasets', :action => 'update') %>',
        data: 'dataset=' + datasetId + '&identifier=' + identifier,
        headers: { 'X-CSRF-Token': '<%= form_authenticity_token.to_s %>' },
        success: function(xhr, data, status) { updateScreen(JSON.parse(data).status); }
      });
    }

    // User has updated an input or output entry slot (called via onChange event)
    function onTextEntryChanged() {
      $('#input-output-form').submit();
    }

  <% end %>

  <%# Creates fn called populateInputTable or populateOutputTable %>
  // formValues & datasetValues will only be defined when calling from the main Module Configuration page
  // When mode is output, datasetValues will be undefined
  function populate<%= mode.slice(0,1).capitalize + mode.slice(1..-1) %>Table(items, formValues, datasetValues)
  {
    var itemCount = items.length;

    var table = $('#<%= mode %>-table');    // Find the exsiting table called input-table or output-table

    if(itemCount == 0) {
      if('<%= mode %>' == 'input') {
        table.html("<span class='no-inputs-ouputs'>This module configuration requires no inputs.</span>");
      }
      else {
        table.html("<span class='no-inputs-ouputs'>This module configuration produces no outputs.</span>");
      }
    }
    else {

      table.empty();

      var headerRow = '<tr><th>Parameter Name</th>' +
                      '<% if mode == :input %><th>Selected Dataset or Value</th><% else %><th>Output Dataset Identifier</th><% end %></tr>';

      table.append(headerRow);



      for(var i = 0; i < itemCount; i++)
      {
        var row  = $(document.createElement('tr'));
        var cell = $(document.createElement('td'));   // Param name

        item = items[i];

        cell.html(item.title);

        if(item.descr != null) {
          cell.append('<img src="/assets/small_question_mark.gif" style="padding-left: 8px; padding-top: 3px" ' +
                  'alt="More info" title="' + item.descr + '">');
        }

        row.append(cell);

        cell = $(document.createElement('td'));   // Dataset
        cell.attr("nowrap", true);


        if('<%= mode %>' == 'input' && items[i].type == "complex") {
          var control = createDatasetSelectionControl(item.identifier, '<%= mode %>');

          if(control.children().length == 0) {
              cell.text('No registered datasets of this type');
              anyDatasetsMissing = true;
          }
          else {
            control.prepend("<option value=-1>No dataset selected</option>");
            control.change(onSelectedDatasetChanged);
            control.attr('class', 'req-select');

            cell.html(control);

            if(datasetValues != undefined)  {
              var selectedVal = datasetValues[item.identifier];
              if(selectedVal != undefined)  {
                control.val(selectedVal);
              }
            }
          }
        }
        else {    // Data is a simple type like integer or string -- use a textfield
          var value       = (formValues == undefined)   ? ""                    : formValues[item.identifier + '<%= mode %>'];
          var placeholder = ('<%= mode %>' == 'output') ? "Output dataset name" : items[i].type.capitalize() + " value";

          cell.html('<input type="text" name="<%= mode %>[' + item.identifier + ']" placeholder="' + placeholder + '" ' +
                           'value="' + value + '" class="req-textentry" onchange="onTextEntryChanged()">');
        }

        row.append(cell);
        table.append(row);

      }
    }
  }


  // discoveredLayers comes from the /shared/_build_data_layers partial
  function createDatasetSelectionControl(identifier, mode)
  {
    var ctrl = $(document.createElement('select'));
    ctrl.attr('name', 'datasets[' + identifier + ']');
    ctrl.attr('id', identifier + mode);

    for(var layerKey in registeredDataLayers) {
      if(registeredDataLayers[layerKey].identifier == identifier) {
        var title = "Unknown Title";
        if(discoveredLayers[layerKey] != undefined) {
          title = discoveredLayers[layerKey].title;
        }

        // Here we create our dropdown of possible datasets.  All datasets presented have already been registered with the server.
        // Note that the value here will be the id of this layer as stored in the database on the server.
        ctrl.append('<option value="' + registeredDataLayers[layerKey].rubyId + '">' + title + '</option>');
      }
    }

    return ctrl;
  }

 </script>
